import type { SupabaseClient } from "../../db/supabase.client";
import { LoggerService } from "./logger.service";

/**
 * Internal type for a match pair generated by the algorithm.
 */
interface MatchPair {
  giver_id: string;
  recipient_id: string;
}

/**
 * Internal type for a provisioned account.
 */
interface ProvisionedAccount {
  participant_id: string;
  user_id: string;
  temporary_password: string;
}

/**
 * Internal type for a participant with user_id field.
 */
interface ParticipantWithUserId {
  id: string;
  name: string;
  surname: string;
  email: string;
  gift_preferences: string;
  user_id: string | null;
}

/**
 * Service responsible for Secret Santa matching operations.
 */
export class MatchingService {
  constructor(private readonly supabase: SupabaseClient) {}

  /**
   * Generates a cryptographically secure random password.
   *
   * @returns A 16-character password with alphanumeric and special characters
   */
  private generateSecurePassword(): string {
    const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*";
    const length = 16;
    let password = "";

    // Use crypto.getRandomValues for secure random generation
    const randomValues = new Uint8Array(length);
    crypto.getRandomValues(randomValues);

    for (let i = 0; i < length; i++) {
      password += charset[randomValues[i] % charset.length];
    }

    return password;
  }

  /**
   * Shuffles an array using Fisher-Yates algorithm.
   *
   * @param array - The array to shuffle
   * @returns A new shuffled array
   */
  private shuffleArray<T>(array: T[]): T[] {
    const shuffled = [...array];

    for (let i = shuffled.length - 1; i > 0; i--) {
      // Generate cryptographically secure random index
      const randomBytes = new Uint32Array(1);
      crypto.getRandomValues(randomBytes);
      const j = randomBytes[0] % (i + 1);

      // Swap elements
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }

    return shuffled;
  }

  /**
   * Validates that there are at least 3 participants.
   *
   * @param participantCount - The number of participants
   * @throws Error if participant count is less than 3
   */
  private validateParticipantCount(participantCount: number): void {
    if (participantCount < 3) {
      throw new Error("Insufficient participants. At least 3 participants are required for matching");
    }
  }

  /**
   * Runs the Secret Santa matching algorithm.
   *
   * Creates circular assignments where each participant gives to exactly one other
   * participant and receives from exactly one other participant.
   *
   * @param participants - Array of participants to match
   * @returns Array of match pairs (giver -> recipient)
   * @throws Error if participant count is less than 3
   */
  runMatchingAlgorithm(participants: ParticipantWithUserId[]): MatchPair[] {
    // Validate minimum participant count
    this.validateParticipantCount(participants.length);

    // Shuffle participants to randomize assignments
    const shuffled = this.shuffleArray(participants);

    // Generate circular assignments: person at index i gives to person at index (i + 1) % n
    const matches: MatchPair[] = [];
    for (let i = 0; i < shuffled.length; i++) {
      const giver = shuffled[i];
      const recipient = shuffled[(i + 1) % shuffled.length];

      matches.push({
        giver_id: giver.id,
        recipient_id: recipient.id,
      });
    }

    return matches;
  }

  /**
   * Provisions Supabase authentication accounts for participants who don't have user_id.
   *
   * Creates user accounts via Supabase Admin API and returns provisioned account details.
   *
   * TODO: Currently mocked - requires service role key for admin access
   * For now, skips account provisioning and logs participants who would need accounts
   *
   * @param participants - Array of all participants (with or without user_id)
   * @returns Array of provisioned accounts with temporary passwords
   * @throws Error if account provisioning fails
   */
  async provisionAccounts(participants: ParticipantWithUserId[]): Promise<ProvisionedAccount[]> {
    // Filter participants who need accounts (user_id is NULL)
    const participantsWithoutAccounts = participants.filter((p) => p.user_id === null);

    if (participantsWithoutAccounts.length === 0) {
      await LoggerService.info("No accounts to provision - all participants have user_id");
      return [];
    }

    // TODO: Uncomment when service role key is available
    // For now, skip account provisioning to allow matching algorithm to work
    await LoggerService.info(
      `[MOCK] Skipping account provisioning for ${participantsWithoutAccounts.length} participants (requires admin key)`
    );
    await LoggerService.info("Participants without accounts:", {
      emails: participantsWithoutAccounts.map((p) => p.email),
    });
    return [];

    /* COMMENTED OUT - Requires Admin Access
    await LoggerService.info(`Provisioning ${participantsWithoutAccounts.length} accounts`);

    // Provision accounts in parallel for better performance
    const provisioningPromises = participantsWithoutAccounts.map(async (participant) => {
      try {
        const temporaryPassword = this.generateSecurePassword();

        // Create user via Supabase Admin API
        const { data, error } = await this.supabase.auth.admin.createUser({
          email: participant.email,
          password: temporaryPassword,
          email_confirm: true,
          user_metadata: {
            name: participant.name,
            surname: participant.surname,
          },
        });

        if (error) {
          await LoggerService.error(`Failed to create user account for ${participant.email}`, error);
          throw new Error(`Failed to create user account: ${error.message}`);
        }

        if (!data.user) {
          throw new Error("User creation succeeded but no user data returned");
        }

        return {
          participant_id: participant.id,
          user_id: data.user.id,
          temporary_password: temporaryPassword,
        };
      } catch (error) {
        await LoggerService.error(`Account provisioning failed for participant ${participant.id}`, error);
        throw error;
      }
    });

    try {
      const provisionedAccounts = await Promise.all(provisioningPromises);
      await LoggerService.info(`Successfully provisioned ${provisionedAccounts.length} accounts`);
      return provisionedAccounts;
    } catch (error) {
      await LoggerService.error("Account provisioning batch failed", error);
      throw new Error("Failed to provision all accounts");
    }
    */
  }

  /**
   * Updates draw_participants table with newly provisioned user_ids.
   *
   * @param provisionedAccounts - Array of provisioned accounts with participant-to-user mappings
   * @throws Error if database update fails
   */
  async updateParticipantUserIds(provisionedAccounts: ProvisionedAccount[]): Promise<void> {
    if (provisionedAccounts.length === 0) {
      return;
    }

    await LoggerService.info(`Updating user_ids for ${provisionedAccounts.length} participants`);

    // Update participants in parallel
    const updatePromises = provisionedAccounts.map(async (account) => {
      const { error } = await this.supabase
        .from("draw_participants")
        .update({ user_id: account.user_id })
        .eq("id", account.participant_id);

      if (error) {
        await LoggerService.error(`Failed to update user_id for participant ${account.participant_id}`, error);
        throw new Error(`Failed to update participant user_id: ${error.message}`);
      }
    });

    try {
      await Promise.all(updatePromises);
      await LoggerService.info("Successfully updated all participant user_ids");
    } catch (error) {
      await LoggerService.error("Failed to update participant user_ids", error);
      throw new Error("Failed to update participant user_ids");
    }
  }

  /**
   * Saves match pairs to the matches table.
   *
   * @param drawId - The UUID of the draw
   * @param matches - Array of match pairs to save
   * @throws Error if database insert fails
   */
  async saveMatches(drawId: string, matches: MatchPair[]): Promise<void> {
    if (matches.length === 0) {
      throw new Error("No matches to save");
    }

    await LoggerService.info(`Saving ${matches.length} matches for draw ${drawId}`);

    // Prepare batch insert records
    const matchRecords = matches.map((match) => ({
      draw_id: drawId,
      giver_id: match.giver_id,
      recipient_id: match.recipient_id,
    }));

    // Execute batch insert
    const { error } = await this.supabase.from("matches").insert(matchRecords);

    if (error) {
      await LoggerService.error(`Failed to save matches for draw ${drawId}`, error);
      throw new Error(`Failed to save matches: ${error.message}`);
    }

    await LoggerService.info(`Successfully saved ${matches.length} matches`);
  }

  /**
   * Checks if matches already exist for a given draw.
   *
   * @param drawId - The UUID of the draw
   * @returns true if matches exist, false otherwise
   */
  async matchesExist(drawId: string): Promise<boolean> {
    const { count, error } = await this.supabase
      .from("matches")
      .select("*", { count: "exact", head: true })
      .eq("draw_id", drawId);

    if (error) {
      await LoggerService.error(`Failed to check existing matches for draw ${drawId}`, error);
      throw new Error("Failed to check existing matches");
    }

    return (count ?? 0) > 0;
  }

  /**
   * Main orchestration function to generate matches for a draw.
   *
   * This function:
   * 1. Fetches all participants for the draw
   * 2. Validates minimum participant count
   * 3. Runs the matching algorithm
   * 4. Provisions accounts for participants without user_id
   * 5. Updates participant records with new user_ids
   * 6. Saves matches to database
   *
   * @param drawId - The UUID of the draw
   * @throws Error if any step fails
   */
  async generateMatches(drawId: string): Promise<void> {
    try {
      await LoggerService.info(`Starting match generation for draw ${drawId}`);

      // Step 1: Fetch all participants
      const { data: participants, error: fetchError } = await this.supabase
        .from("draw_participants")
        .select("id, name, surname, email, gift_preferences, user_id")
        .eq("draw_id", drawId)
        .order("created_at", { ascending: true });

      if (fetchError || !participants) {
        await LoggerService.error(`Failed to fetch participants for draw ${drawId}`, fetchError);
        throw new Error("Failed to fetch participants");
      }

      // Step 2: Validate minimum participant count
      this.validateParticipantCount(participants.length);

      // Step 3: Run matching algorithm
      const matches = this.runMatchingAlgorithm(participants);
      await LoggerService.info(`Generated ${matches.length} matches`);

      // Step 4: Provision accounts for participants without user_id
      const provisionedAccounts = await this.provisionAccounts(participants);

      // Step 5: Update participant records with new user_ids
      if (provisionedAccounts.length > 0) {
        await this.updateParticipantUserIds(provisionedAccounts);
      }

      // Step 6: Save matches to database
      await this.saveMatches(drawId, matches);

      // TODO: Step 7: Send invitation emails (mocked for MVP)
      if (provisionedAccounts.length > 0) {
        await LoggerService.info(`[MOCK] Would send ${provisionedAccounts.length} invitation emails`);
        // In production, call email service here
        // await this.sendInvitationEmails(provisionedAccounts);
      }

      await LoggerService.info(`Successfully completed match generation for draw ${drawId}`);
    } catch (error) {
      await LoggerService.error(`Match generation failed for draw ${drawId}`, error);
      throw error;
    }
  }
}
